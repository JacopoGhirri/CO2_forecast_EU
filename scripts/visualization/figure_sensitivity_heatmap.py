"""
Figure 4: Sensitivity Analysis Dual Heatmap.

Generates publication-quality two-panel figures showing:
  (a) Total-order Sobol indices (ST) across emission sectors
  (b) Spearman correlation importance across emission sectors

This visualizes which input variables most strongly influence each sector's
emission predictions. Total-order indices (ST) capture each variable's full
contribution to output variance including all interaction effects, while
Spearman correlations indicate the direction of influence.

Variable Modes:
    - "full": Includes both input variables and context variables
    - "inputonly": Includes only input variables (excludes context)

Both modes are generated by default, producing separate figures for each.

Usage:
    python -m scripts.visualization.figure_sensitivity_heatmap

Outputs:
    For each mode (full/inputonly):
    - outputs/figures/fig4_dual_sensitivity_heatmap_{mode}.pdf
    - outputs/figures/fig4_dual_sensitivity_heatmap_{mode}.png

Reference:
    Figure 4 in the paper shows sensitivity analysis results.
"""

from pathlib import Path
from typing import Literal

import matplotlib.gridspec as gridspec
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
from matplotlib.colors import LinearSegmentedColormap, TwoSlopeNorm

# =============================================================================
# Configuration
# =============================================================================

# Variable mode type
VariableMode = Literal["full", "inputonly"]

# Input paths (mode is substituted at runtime)
SENSITIVITY_DIR = Path("data/sensitivity")
OUTPUT_DIR = Path("outputs/figures")

# Which modes to generate figures for
GENERATE_MODES: list[VariableMode] = ["full", "inputonly"]

# Display settings
VMAX_SOBOL = 0.60
VMAX_SPEARMAN = 0.80
VARIABLE_SELECTION_MODE = "top_per_sector"
VARIABLE_SOURCE = "sobol"
TOP_N_PER_SECTOR = 3

# Sector configuration
SECTOR_ORDER = ["HeatingCooling", "Industry", "Land", "Mobility", "Other", "Power"]
SECTOR_LABELS = [
    "Heating &\nCooling",
    "Industry",
    "Land Use",
    "Mobility",
    "Other",
    "Power",
]

# Variable name mapping
NAME_MAP = {
    "Monthly_electricity_statistics:Net Electricity Production:Solar": "Solar power",
    "Monthly_electricity_statistics:Net Electricity Production:Total Combustible Fuels": "Fossil fuels power",
    "Monthly_electricity_statistics:Net Electricity Production:Wind": "Wind power",
    "Monthly_electricity_statistics:Used for pumped storage:Electricity": "Pumped storage",
    "Monthly_oil_price_statistics:Diesel (unit/litre):Total price:US dollars": "Diesel price",
    "Monthly_oil_price_statistics:Domestic heating oil (unit/litre):Total price:US dollars": "Heating oil price",
    "Monthly_oil_price_statistics:Gasoline (unit/litre):Total price:US dollars": "Gasoline price",
    "CONTEXT::gdp_quarterly:MillionEUR": "GDP",
    "CONTEXT::climate:rainfall:POP": "Precipitation (pop.)",
    "CONTEXT::climate:temperature:POP": "Temperature (pop.)",
    "CONTEXT::climate:temperature:AREA": "Temperature (area)",
    "CONTEXT::climate:temperature_variability:POP": "Temp. variability (pop.)",
    "CONTEXT::climate:temperature_variability:AREA": "Temp. variability (area)",
    "CONTEXT::climate:rainfall:AREA": "Precipitation (area)",
    "CONTEXT::population:POP_NC": "Population",
    "carbon_price:EU_ETS": "ETS price",
    "heat_pumps:GWH": "Heat pump capacity",
    "land_use:Cropland:Area:1000_ha": "Cropland area",
    "land_use:Forest_land:Area:1000_ha": "Forest area",
    "modal_split_transport:AIR": "Modal split (air)",
    "modal_split_transport:RAIL": "Modal split (rail)",
    "modal_split_transport:ROAD": "Modal split (road)",
    "modal_split_transport:SEA": "Modal split (sea)",
    "energy_taxes:MIOEUR": "Energy taxes",
    "EV_data:EV sales:Cars:BEV:Vehicles": "EV car sales (BEV)",
    "EV_data:EV stock share:Cars:EV:percent": "EV car stock share",
    "crops_livestock:Wheat:Production:t": "Wheat production",
    "crops_livestock:Meat,_Total:Production:t": "Meat production (total)",
    "trade:import_volume_index:Raw_materials:WORLD": "Import vol. (raw mat.)",
    "trade:import_volume_index:Mineral_fuels_lubrificants:WORLD": "Import vol. (fuels)",
    "train_performance:Passenger_trains:Total:Diesel:THS_train_mk": "Passenger trains (diesel)",
    "train_performance:Passenger_trains:Total:Electricity:THS_train_mk": "Passenger trains (elec.)",
    "Monthly_electricity_statistics:Distribution Losses:Electricity": "Electricity losses",
    "Monthly_electricity_statistics:Net Electricity Production:Hydro": "Hydro power",
    "Monthly_electricity_statistics:Net Electricity Production:Total Renewables (Hydro, Geo, Solar, Wind, Other)": "Renewables (total)",
    "Monthly_electricity_statistics:Total Exports:Electricity": "Electricity exports",
    "Monthly_electricity_statistics:Total Imports:Electricity": "Electricity imports",
    "solar_thermal_surface:THS_M2": "Solar thermal surface",
    "energy_consumption:FC_E:GJ_HAB": "Energy cons. (total)",
    "energy_consumption:FC_IND_E:GJ_HAB": "Energy cons. (industry)",
    "energy_consumption:FC_TRA_E:GJ_HAB": "Energy cons. (transport)",
}

# Variable categories for grouping and sorting
VAR_CATEGORIES = {
    "Temperature (pop.)": ("Climate", 0),
    "Temperature (area)": ("Climate", 1),
    "Precipitation (pop.)": ("Climate", 2),
    "Precipitation (area)": ("Climate", 3),
    "Temp. variability (pop.)": ("Climate", 4),
    "Temp. variability (area)": ("Climate", 5),
    "GDP": ("Economic", 10),
    "Population": ("Economic", 11),
    "ETS price": ("Economic", 12),
    "Energy taxes": ("Economic", 13),
    "Diesel price": ("Energy prices", 20),
    "Gasoline price": ("Energy prices", 21),
    "Heating oil price": ("Energy prices", 22),
    "Wind power": ("Electricity", 30),
    "Solar power": ("Electricity", 31),
    "Hydro power": ("Electricity", 32),
    "Fossil fuels power": ("Electricity", 33),
    "Renewables (total)": ("Electricity", 34),
    "Pumped storage": ("Electricity", 35),
    "Electricity exports": ("Electricity", 36),
    "Electricity imports": ("Electricity", 37),
    "Electricity losses": ("Electricity", 38),
    "Heat pump capacity": ("Heating", 40),
    "Solar thermal surface": ("Heating", 41),
    "EV car sales (BEV)": ("Transport", 50),
    "EV car stock share": ("Transport", 52),
    "Modal split (air)": ("Transport", 54),
    "Modal split (rail)": ("Transport", 55),
    "Modal split (road)": ("Transport", 56),
    "Modal split (sea)": ("Transport", 57),
    "Passenger trains (diesel)": ("Transport", 58),
    "Passenger trains (elec.)": ("Transport", 59),
    "Cropland area": ("Land use", 70),
    "Forest area": ("Land use", 71),
    "Wheat production": ("Agriculture", 80),
    "Meat production (total)": ("Agriculture", 81),
    "Import vol. (raw mat.)": ("Trade", 90),
    "Import vol. (fuels)": ("Trade", 93),
    "Energy cons. (total)": ("Energy demand", 100),
    "Energy cons. (industry)": ("Energy demand", 101),
    "Energy cons. (transport)": ("Energy demand", 102),
}


def setup_nature_style():
    """Configure matplotlib for Nature Climate Change publication style."""
    plt.rcParams.update(
        {
            "font.family": "sans-serif",
            "font.sans-serif": ["Helvetica Neue", "Helvetica", "Arial", "DejaVu Sans"],
            "font.size": 7,
            "axes.linewidth": 0.5,
            "axes.labelsize": 7,
            "axes.titlesize": 8,
            "xtick.labelsize": 6.5,
            "ytick.labelsize": 7,
            "legend.fontsize": 6,
            "figure.dpi": 300,
            "pdf.fonttype": 42,
            "ps.fonttype": 42,
        }
    )


def filter_context_variables(df: pd.DataFrame, include_context: bool) -> pd.DataFrame:
    """Filter out CONTEXT:: variables if requested."""
    if not include_context:
        mask = ~df["var"].str.startswith("CONTEXT::")
        return df[mask].copy()
    return df.copy()


def select_variables_top_per_sector(pivot: pd.DataFrame, top_n: int) -> set:
    """Select top N variables per sector based on total-order Sobol index (ST)."""
    selected = set()
    for sector in pivot.columns:
        top_in_sector = pivot[sector].sort_values(ascending=False).head(top_n).index
        selected.update(top_in_sector)
    return selected


def sort_variables_by_category(variables: list) -> list:
    """Sort variables by their category order."""
    return sorted(variables, key=lambda x: VAR_CATEGORIES.get(x, ("ZZZ", 999))[1])


def get_category_boundaries(sorted_vars: list) -> list:
    """Find row indices where category changes."""
    boundaries = []
    prev_cat = None
    for idx, var in enumerate(sorted_vars):
        cat = VAR_CATEGORIES.get(var, ("Unknown", 999))[0]
        if prev_cat is not None and cat != prev_cat:
            boundaries.append(idx - 0.5)
        prev_cat = cat
    return boundaries


def create_dual_heatmap(mode: VariableMode = "full"):
    """
    Generate publication-quality dual sensitivity heatmap for a given mode.

    Panel (a) shows total-order Sobol indices (ST) and panel (b) shows
    signed Spearman correlation importance.

    Args:
        mode: Variable mode - "full" or "inputonly"
    """
    setup_nature_style()

    print("=" * 70)
    print(f"GENERATING FIGURE 4: SENSITIVITY HEATMAP ({mode.upper()})")
    print("=" * 70)

    # Construct file paths based on mode
    sobol_csv = SENSITIVITY_DIR / f"sobol_results_{mode}.csv"
    spearman_csv = SENSITIVITY_DIR / f"perturbation_results_{mode}.csv"

    # Load Sobol data
    if not sobol_csv.exists():
        print(f"Error: Sobol results not found at {sobol_csv}")
        print("Run scripts.analysis.sensitivity.sobol_analysis first.")
        return

    df_sobol = pd.read_csv(sobol_csv)
    df_sobol["var_clean"] = df_sobol["var"].map(NAME_MAP).fillna(df_sobol["var"])

    pivot_st = df_sobol.pivot(index="var_clean", columns="sector", values="ST")
    pivot_conf = df_sobol.pivot(index="var_clean", columns="sector", values="ST_conf")

    available_sectors_sobol = [s for s in SECTOR_ORDER if s in pivot_st.columns]
    pivot_st = pivot_st[available_sectors_sobol]
    pivot_conf = pivot_conf[available_sectors_sobol]

    # Load Spearman data
    if not spearman_csv.exists():
        print(f"Error: Spearman results not found at {spearman_csv}")
        print("Run scripts.analysis.sensitivity.perturbation_analysis first.")
        return

    df_spearman = pd.read_csv(spearman_csv)
    df_spearman["var_clean"] = (
        df_spearman["var"].map(NAME_MAP).fillna(df_spearman["var"])
    )
    df_spearman["signed_importance"] = (
        df_spearman["importance_abs_corr"] * df_spearman["pearson_corr_sign"]
    )

    pivot_spearman = df_spearman.pivot(
        index="var_clean", columns="sector", values="signed_importance"
    )
    pivot_spearman_abs = df_spearman.pivot(
        index="var_clean", columns="sector", values="importance_abs_corr"
    )

    available_sectors_spearman = [
        s for s in SECTOR_ORDER if s in pivot_spearman.columns
    ]
    pivot_spearman = pivot_spearman[available_sectors_spearman]
    pivot_spearman_abs = pivot_spearman_abs[available_sectors_spearman]

    # Variable selection based on ST
    print("\nSelecting variables (by total-order Sobol index ST)...")
    selected_vars = select_variables_top_per_sector(pivot_st, TOP_N_PER_SECTOR)
    common_vars = set(pivot_st.index) & set(pivot_spearman.index)
    selected_vars = selected_vars & common_vars
    selected_vars_sorted = sort_variables_by_category(list(selected_vars))
    n_vars = len(selected_vars_sorted)

    print(f"Selected {n_vars} variables")
    for i, v in enumerate(selected_vars_sorted):
        cat = VAR_CATEGORIES.get(v, ("Unknown", -1))[0]
        print(f"  {i + 1:2d}. {v} ({cat})")

    # Filter pivots
    pivot_st = pivot_st.loc[selected_vars_sorted]
    pivot_conf = pivot_conf.loc[selected_vars_sorted]
    pivot_spearman = pivot_spearman.loc[selected_vars_sorted]

    # Figure setup
    fig_width = 7.08
    fig_height = max(4.0, 0.24 * n_vars + 2.0)
    fig = plt.figure(figsize=(fig_width, fig_height))

    gs = gridspec.GridSpec(
        3,
        2,
        height_ratios=[1.2, 1, 10],
        width_ratios=[1, 1],
        hspace=0.15,
        wspace=0.12,
    )

    ax_title_a = fig.add_subplot(gs[0, 0])
    ax_title_b = fig.add_subplot(gs[0, 1])
    ax_cbar_sobol = fig.add_subplot(gs[1, 0])
    ax_cbar_spearman = fig.add_subplot(gs[1, 1])
    ax_sobol = fig.add_subplot(gs[2, 0])
    ax_spearman = fig.add_subplot(gs[2, 1])

    for ax_title in [ax_title_a, ax_title_b]:
        ax_title.set_axis_off()

    ax_title_a.text(
        0.0,
        0.50,
        "a",
        fontsize=10,
        fontweight="bold",
        transform=ax_title_a.transAxes,
        va="bottom",
        ha="left",
    )
    ax_title_a.text(
        0.06,
        0.50,
        "Sobol sensitivity (ST)",
        fontsize=9,
        transform=ax_title_a.transAxes,
        va="bottom",
        ha="left",
    )

    ax_title_b.text(
        0.0,
        0.50,
        "b",
        fontsize=10,
        fontweight="bold",
        transform=ax_title_b.transAxes,
        va="bottom",
        ha="left",
    )
    ax_title_b.text(
        0.06,
        0.50,
        "Spearman correlation",
        fontsize=9,
        transform=ax_title_b.transAxes,
        va="bottom",
        ha="left",
    )

    # Colormaps
    colors_sobol = [
        "#FFFFFF",
        "#FFF7EC",
        "#FEE8C8",
        "#FDD49E",
        "#FDBB84",
        "#FC8D59",
        "#EF6548",
        "#D7301F",
        "#990000",
    ]
    cmap_sobol = LinearSegmentedColormap.from_list("warm", colors_sobol, N=256)

    colors_diverging = [
        "#053061",
        "#2166AC",
        "#4393C3",
        "#92C5DE",
        "#D1E5F0",
        "#FFFFFF",
        "#FDDBC7",
        "#F4A582",
        "#D6604D",
        "#B2182B",
        "#67001F",
    ]
    cmap_spearman = LinearSegmentedColormap.from_list(
        "diverging", colors_diverging, N=256
    )

    # Panel A: Sobol ST heatmap
    data_sobol = pivot_st.values
    n_sectors = len(available_sectors_sobol)

    im_sobol = ax_sobol.imshow(
        data_sobol, cmap=cmap_sobol, aspect="auto", vmin=0, vmax=VMAX_SOBOL
    )

    for i in range(n_vars):
        for j in range(n_sectors):
            val = data_sobol[i, j]
            if np.isnan(val):
                continue
            conf = (
                pivot_conf.values[i, j] if not np.isnan(pivot_conf.values[i, j]) else 0
            )
            text_color = "white" if val > 0.40 else "#333333"
            weight = "bold" if val > 0.10 and val > 2 * conf else "normal"
            ax_sobol.text(
                j,
                i,
                f"{abs(val):.2f}",
                ha="center",
                va="center",
                fontsize=5.5,
                color=text_color,
                fontweight=weight,
            )

    ax_sobol.set_xticks(range(n_sectors))
    sector_labels = [
        SECTOR_LABELS[SECTOR_ORDER.index(s)] for s in available_sectors_sobol
    ]
    ax_sobol.set_xticklabels(sector_labels, ha="center", linespacing=0.85)
    ax_sobol.set_yticks(range(n_vars))
    ax_sobol.set_yticklabels(selected_vars_sorted)
    ax_sobol.tick_params(axis="both", which="both", length=0)

    for i in range(n_vars + 1):
        ax_sobol.axhline(i - 0.5, color="white", linewidth=0.5)
    for j in range(n_sectors + 1):
        ax_sobol.axvline(j - 0.5, color="white", linewidth=0.5)

    for pos in get_category_boundaries(selected_vars_sorted):
        ax_sobol.axhline(pos, color="#444444", linewidth=1.0)

    ax_sobol.set_xlabel("Emission sector", fontsize=7, labelpad=8)

    for spine in ax_sobol.spines.values():
        spine.set_linewidth(0.5)
        spine.set_color("#333333")

    # Panel B: Spearman heatmap
    data_spearman = pivot_spearman.values
    n_sectors_sp = len(available_sectors_spearman)

    norm_spearman = TwoSlopeNorm(vmin=-VMAX_SPEARMAN, vcenter=0, vmax=VMAX_SPEARMAN)

    im_spearman = ax_spearman.imshow(
        data_spearman, cmap=cmap_spearman, aspect="auto", norm=norm_spearman
    )

    for i in range(n_vars):
        for j in range(n_sectors_sp):
            val = data_spearman[i, j]
            if np.isnan(val):
                continue
            text_color = "white" if abs(val) > 0.50 else "#333333"
            weight = "bold" if abs(val) > 0.20 else "normal"
            ax_spearman.text(
                j,
                i,
                f"{val:.2f}",
                ha="center",
                va="center",
                fontsize=5.5,
                color=text_color,
                fontweight=weight,
            )

    ax_spearman.set_xticks(range(n_sectors_sp))
    sector_labels_sp = [
        SECTOR_LABELS[SECTOR_ORDER.index(s)] for s in available_sectors_spearman
    ]
    ax_spearman.set_xticklabels(sector_labels_sp, ha="center", linespacing=0.85)
    ax_spearman.set_yticks(range(n_vars))
    ax_spearman.set_yticklabels([])
    ax_spearman.tick_params(axis="both", which="both", length=0)

    for i in range(n_vars + 1):
        ax_spearman.axhline(i - 0.5, color="white", linewidth=0.5)
    for j in range(n_sectors_sp + 1):
        ax_spearman.axvline(j - 0.5, color="white", linewidth=0.5)

    for pos in get_category_boundaries(selected_vars_sorted):
        ax_spearman.axhline(pos, color="#444444", linewidth=1.0)

    ax_spearman.set_xlabel("Emission sector", fontsize=7, labelpad=8)

    for spine in ax_spearman.spines.values():
        spine.set_linewidth(0.5)
        spine.set_color("#333333")

    # Colorbars
    cbar_sobol = plt.colorbar(im_sobol, cax=ax_cbar_sobol, orientation="horizontal")
    cbar_sobol.set_label("Total-order Sobol index (ST)", fontsize=6.5, labelpad=3)
    cbar_sobol.ax.tick_params(labelsize=6, length=2, width=0.4, pad=1)
    cbar_sobol.ax.xaxis.set_ticks_position("top")
    cbar_sobol.ax.xaxis.set_label_position("top")
    cbar_sobol.outline.set_linewidth(0.4)
    cbar_sobol.set_ticks([0, 0.15, 0.30, 0.45, 0.60])

    cbar_spearman = plt.colorbar(
        im_spearman, cax=ax_cbar_spearman, orientation="horizontal"
    )
    cbar_spearman.set_label("Signed correlation importance", fontsize=6.5, labelpad=3)
    cbar_spearman.ax.tick_params(labelsize=6, length=2, width=0.4, pad=1)
    cbar_spearman.ax.xaxis.set_ticks_position("top")
    cbar_spearman.ax.xaxis.set_label_position("top")
    cbar_spearman.outline.set_linewidth(0.4)
    cbar_spearman.set_ticks([-0.8, -0.4, 0, 0.4, 0.8])

    # Save
    OUTPUT_DIR.mkdir(parents=True, exist_ok=True)
    for fmt in ["pdf", "png"]:
        plt.savefig(
            OUTPUT_DIR / f"fig4_dual_sensitivity_heatmap_{mode}.{fmt}",
            bbox_inches="tight",
            dpi=300,
            facecolor="white",
            edgecolor="none",
        )

    print(f"\nSaved: {OUTPUT_DIR}/fig4_dual_sensitivity_heatmap_{mode}.[pdf|png]")
    plt.close()


def main():
    """Generate Figure 4: Sensitivity Analysis Heatmap for all modes."""
    print("=" * 70)
    print("GENERATING FIGURE 4: SENSITIVITY HEATMAPS")
    print(f"Modes to generate: {GENERATE_MODES}")
    print("=" * 70)

    for mode in GENERATE_MODES:
        print(f"\n--- Generating {mode} mode ---")
        create_dual_heatmap(mode=mode)

    print("\n" + "=" * 70)
    print("Figure 4 generation complete for all modes!")
    print("=" * 70)


def generate_single_mode(mode: VariableMode) -> None:
    """
    Generate sensitivity heatmap for a single mode.

    Args:
        mode: Variable mode - "full" or "inputonly"
    """
    create_dual_heatmap(mode=mode)


if __name__ == "__main__":
    main()